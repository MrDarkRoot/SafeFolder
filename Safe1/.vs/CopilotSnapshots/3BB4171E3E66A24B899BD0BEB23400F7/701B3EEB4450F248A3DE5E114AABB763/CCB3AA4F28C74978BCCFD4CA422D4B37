using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Threading.Tasks;

namespace Safe1.Services
{
    public static class EncryptionService
    {
        private const string NativeDll = "SafeFolder.NativeCrypto.dll";
        private const int FileKeySize = 32; // 256-bit
        private const int PBKDF2Iterations = 310000;

        // P/Invoke declarations
        [DllImport(NativeDll, CallingConvention = CallingConvention.Cdecl)]
        private static extern int PBKDF2_Derive(IntPtr passwordAnsi, byte[] salt, int saltLen, int iterations, byte[] outKey, int outKeyLen);

        [DllImport(NativeDll, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
        private static extern int EncryptFileAesGcm(string inPath, string outPath, byte[] key, int keyLen, byte[] iv, int ivLen);

        [DllImport(NativeDll, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
        private static extern int DecryptFileAesGcm(string inPath, string outPath, byte[] key, int keyLen, byte[] iv, int ivLen);

        /// <summary>
        /// Derive a 32-byte file key from the given master password and salt using PBKDF2-SHA256 (native implementation).
        /// Uses SecureString -> global ANSI buffer to avoid leaving password as managed string bytes.
        /// </summary>
        public static byte[] DeriveFileKeyFromMaster(string masterPassword, byte[] salt)
        {
            if (masterPassword == null) throw new ArgumentNullException(nameof(masterPassword));
            if (salt == null) throw new ArgumentNullException(nameof(salt));

            var outKey = new byte[FileKeySize];
            IntPtr pwPtr = IntPtr.Zero;
            SecureString secure = null;
            try
            {
                // Build SecureString from plain string
                secure = new SecureString();
                foreach (char c in masterPassword)
                {
                    secure.AppendChar(c);
                }
                secure.MakeReadOnly();

                // Convert to ANSI in unmanaged memory (zeroable via ZeroFreeGlobalAllocAnsi)
                pwPtr = Marshal.SecureStringToGlobalAllocAnsi(secure);

                int rc = PBKDF2_Derive(pwPtr, salt, salt.Length, PBKDF2Iterations, outKey, outKey.Length);
                if (rc != 0)
                {
                    throw new InvalidOperationException($"PBKDF2_Derive failed with code {rc}.");
                }

                return outKey;
            }
            finally
            {
                // Zero and free unmanaged memory
                if (pwPtr != IntPtr.Zero)
                {
                    try { Marshal.ZeroFreeGlobalAllocAnsi(pwPtr); } catch { }
                }

                // Clear securestring
                if (secure != null)
                {
                    try
                    {
                        secure.Dispose();
                    }
                    catch { }
                }

                // Clear masterPassword reference in case caller passed a variable
                // (cannot zero managed string content; recommend caller avoid keeping password around)
            }
        }

        /// <summary>
        /// Encrypts inputPath to outputPath atomically using AES-256-GCM via native library.
        /// Generates a random 12-byte IV. The native library writes ciphertext + tag to outPath.
        /// </summary>
        public static Task EncryptFileAtomicAsync(string inputPath, string outputPath, byte[] fileKey)
        {
            if (string.IsNullOrEmpty(inputPath)) throw new ArgumentNullException(nameof(inputPath));
            if (string.IsNullOrEmpty(outputPath)) throw new ArgumentNullException(nameof(outputPath));
            if (fileKey == null || fileKey.Length != FileKeySize) throw new ArgumentException("fileKey must be 32 bytes", nameof(fileKey));

            return Task.Run(() =>
            {
                var outDir = Path.GetDirectoryName(outputPath);
                if (string.IsNullOrEmpty(outDir)) outDir = Directory.GetCurrentDirectory();
                Directory.CreateDirectory(outDir);

                var tempOut = Path.Combine(outDir, ".tmp_" + Path.GetFileName(outputPath) + "_" + Guid.NewGuid().ToString("N"));

                byte[] iv = new byte[12]; // recommended 12 bytes for GCM
                using (var rng = RandomNumberGenerator.Create()) rng.GetBytes(iv);

                int rc = EncryptFileAesGcm(inputPath, tempOut, fileKey, fileKey.Length, iv, iv.Length);
                if (rc != 0)
                {
                    // cleanup temp file
                    try { if (File.Exists(tempOut)) File.Delete(tempOut); } catch { }
                    throw new InvalidOperationException($"EncryptFileAesGcm failed with code {rc}.");
                }

                // Move temp to final path atomically (replace if exists)
                try
                {
                    if (File.Exists(outputPath)) File.Replace(tempOut, outputPath, null);
                    else File.Move(tempOut, outputPath);
                }
                catch
                {
                    // Attempt fallback
                    try { if (File.Exists(tempOut)) File.Move(tempOut, outputPath); } catch { }
                }
            });
        }

        /// <summary>
        /// Decrypts inputPath (ciphertext+tag) to outputPath atomically. Requires same IV used for encryption.
        /// This implementation expects caller to supply correct IV; if IV is stored elsewhere, adapt accordingly.
        /// </summary>
        public static Task DecryptFileAtomicAsync(string inputPath, string outputPath, byte[] fileKey, byte[] iv)
        {
            if (string.IsNullOrEmpty(inputPath)) throw new ArgumentNullException(nameof(inputPath));
            if (string.IsNullOrEmpty(outputPath)) throw new ArgumentNullException(nameof(outputPath));
            if (fileKey == null || fileKey.Length != FileKeySize) throw new ArgumentException("fileKey must be 32 bytes", nameof(fileKey));
            if (iv == null || iv.Length == 0) throw new ArgumentNullException(nameof(iv));

            return Task.Run(() =>
            {
                var outDir = Path.GetDirectoryName(outputPath);
                if (string.IsNullOrEmpty(outDir)) outDir = Directory.GetCurrentDirectory();
                Directory.CreateDirectory(outDir);

                var tempOut = Path.Combine(outDir, ".tmp_" + Path.GetFileName(outputPath) + "_" + Guid.NewGuid().ToString("N"));

                int rc = DecryptFileAesGcm(inputPath, tempOut, fileKey, fileKey.Length, iv, iv.Length);
                if (rc != 0)
                {
                    try { if (File.Exists(tempOut)) File.Delete(tempOut); } catch { }
                    throw new InvalidOperationException($"DecryptFileAesGcm failed with code {rc}.");
                }

                try
                {
                    if (File.Exists(outputPath)) File.Replace(tempOut, outputPath, null);
                    else File.Move(tempOut, outputPath);
                }
                catch
                {
                    try { if (File.Exists(tempOut)) File.Move(tempOut, outputPath); } catch { }
                }
            });
        }
    }
}
